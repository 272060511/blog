(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{176:function(e,t,v){"use strict";v.r(t);var l=v(0),i=Object(l.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("div",{staticClass:"content"},[v("h2",{attrs:{id:"对于-mvvm-的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对于-mvvm-的理解","aria-hidden":"true"}},[e._v("#")]),e._v(" 对于 MVVM 的理解")]),e._v(" "),v("p",[e._v("MVVM 是 Model-View-ViewModel 的缩写。"),v("br"),e._v("\nModel：代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑。我们可以把 Model 称为数据层，因为它仅仅关注数据本身，不关心任何行为。"),v("br"),e._v("\nView：用户操作界面，当 ViewModel 对 Model 进行更新的时候，会通过数据绑定更新到 View。"),v("br"),e._v("\nViewModel：业务逻辑层，View 需要什么数据，ViewModel 要提供这个数据；View 有某些操作，ViewModel 就要响应这些操作，所以可以说它是 Model for View。"),v("br"),e._v("\n总结："),v("br"),e._v("\nMVVM 模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。")]),e._v(" "),v("h2",{attrs:{id:"vue-开发中常用的指令有哪些？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-开发中常用的指令有哪些？","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue 开发中常用的指令有哪些？")]),e._v(" "),v("p",[e._v("v-model：一般用在表单输入，很轻松的实现表单控件和数据的双向绑定；"),v("br"),e._v("\nv-html：更新元素的 innerHTML；"),v("br"),e._v("\nv-show 与 v-if：条件渲染，注意区别：")]),e._v(" "),v("div",{staticClass:"tip custom-block"},[v("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),v("p",[e._v("使用 v-if 的时候，如果值为 false，那么页面将不会有这个 html 标签生成。v-show 则是不管值为 true 还是 false，html 元素都会存在，只是 css 中的 display 显示或者隐藏。")])]),e._v(" "),v("p",[e._v("v-on:click ：可以简写为@click，@绑定一个事件。如果事件触发了，就可以指定事件的处理函数；"),v("br"),e._v("\nv-for：基于原数据多次渲染元素或者模板块。\nv-bind:可以简写为：，：绑定动态的值或者数据等。")]),e._v(" "),v("h2",{attrs:{id:"对于-vue-生命周期的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对于-vue-生命周期的理解","aria-hidden":"true"}},[e._v("#")]),e._v(" 对于 Vue 生命周期的理解")]),e._v(" "),v("p",[e._v("主要可以划分为：创建前/后，载入前/后，更新前/后，销毁前/后 8 个。")]),e._v(" "),v("ul",[v("li",[e._v("beforeCreate(创建前) Vue 实例的挂载元素 $el 和数据对象 data 都是 undefined，还未初始化。")]),e._v(" "),v("li",[e._v("created(创建后) 完成了 data 数据初始化，el 还未初始化。")]),e._v(" "),v("li",[e._v("beforeMount(载入前) Vue 实例的 $el 和 data 都初始化了，相关的 render 函数首次被调用。实例已完成以下的配置："),v("br"),e._v("\n编译模板，把 data 里面的数据和模板生成 html。注意此时还没有挂载 html 到页面上。")]),e._v(" "),v("li",[e._v("mounted(载入后) 在 el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下配置："),v("br"),e._v("\n用上面编译好的 html 内容替换 el 属性指向 DOM 对象。完成模板中的 html 渲染到 html 页面中。此过程中进行 ajax 交互。")]),e._v(" "),v("li",[e._v("beforeUpdate(更新前) 在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中进一步的更改状态，不会触发附加的重渲染过程。")]),e._v(" "),v("li",[e._v("updated(更新后) 在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无线循环。该钩子在服务器渲染期间不被调用。")]),e._v(" "),v("li",[e._v("beforeDestroy(销毁前) 在实例销毁之前调用。实例仍然完全可用。")]),e._v(" "),v("li",[e._v("destroyed(销毁后) 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。")])])])}],!1,null,null,null);t.default=i.exports}}]);